export type TrendInput={time:number[];close:number[];high:number[];low:number[]};
export function extrema(vals:number[],w:number){const n=vals.length,lows:number[]=[],highs:number[]=[];for(let i=w;i<n-w;i++){let lo=true,hi=true;for(let k=1;k<=w;k++){if(!(vals[i]<=vals[i-k]&&vals[i]<=vals[i+k]))lo=false;if(!(vals[i]>=vals[i-k]&&vals[i]>=vals[i+k]))hi=false}if(lo)lows.push(i);if(hi)highs.push(i)}return{lows,highs}}
export function clusterLevels(vals:number[],tol=0.01){const a=vals.slice().sort((x,y)=>x-y),levels:number[]=[],counts:number[]=[];for(const v of a){if(!levels.length){levels.push(v);counts.push(1);continue}const last=levels[levels.length-1];if(Math.abs(v-last)<=tol*Math.max(1,Math.abs(last))){const c=counts[counts.length-1]+1;counts[counts.length-1]=c;levels[levels.length-1]=(last*(c-1)+v)/c}else{levels.push(v);counts.push(1)}}const maxC=Math.max(...counts),minC=Math.min(...counts),strength=counts.map(c=>(c-minC)/(maxC-minC||1));return{levels,counts,strength}}
export function computeTrend(ohlc:TrendInput,w=10,tol=0.01){const {lows,highs}=extrema(ohlc.close,w);const vals=lows.map(i=>ohlc.close[i]).concat(highs.map(i=>ohlc.close[i]));const {levels,counts,strength}=clusterLevels(vals,tol);return{lows,highs,levels,counts,strength}}

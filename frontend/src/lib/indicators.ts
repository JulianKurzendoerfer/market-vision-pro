export function ema(arr:number[], p:number){const k=2/(p+1);let e:number[]=[];let s=0;for(let i=0;i<arr.length;i++){const v=arr[i];if(i<p-1){s+=v;e.push(NaN)}else if(i===p-1){s+=v;e.push(s/p)}else{e.push(v*k+e[e.length-1]*(1-k))}}return e}
export function sma(arr:number[], p:number){let r:number[]=[];let s=0;for(let i=0;i<arr.length;i++){s+=arr[i];if(i>=p)s-=arr[i-p];r.push(i>=p-1?s/p:NaN)}return r}
export function stdev(arr:number[], p:number){const m=sma(arr,p);let r:number[]=[];for(let i=0;i<arr.length;i++){if(i<p-1){r.push(NaN)}else{let s=0;for(let j=i-p+1;j<=i;j++)s+=Math.pow(arr[j]-m[i],2);r.push(Math.sqrt(s/p))}}return r}
export function bb(close:number[], w=20,k=2){const m=sma(close,w);const sd=stdev(close,w);let up:number[]=[],lo:number[]=[];for(let i=0;i<close.length;i++){if(isNaN(m[i])||isNaN(sd[i])){up.push(NaN);lo.push(NaN)}else{up.push(m[i]+k*sd[i]);lo.push(m[i]-k*sd[i])}}return {mid:m,up,lo}}
export function rsi(close:number[], p=14){let g=0,l=0;for(let i=1;i<=p;i++){const d=close[i]-close[i-1];g+=Math.max(d,0);l+=Math.max(-d,0)}let rs=g/p/(l/p||1e-9);let r:number[]=[];r[p]=100-100/(1+rs);for(let i=p+1;i<close.length;i++){const d=close[i]-close[i-1];const up=Math.max(d,0),dn=Math.max(-d,0);g=(g*(p-1)+up)/p;l=(l*(p-1)+dn)/p;rs=g/(l||1e-9);r[i]=100-100/(1+rs)}for(let i=0;i<p;i++)r[i]=NaN;return r}
export function stochKDL(high:number[],low:number[],close:number[],k=14,d=3){let K:number[]=[];for(let i=0;i<close.length;i++){const a=Math.max(0,i-k+1);let hi=-Infinity,lo=Infinity;for(let j=a;j<=i;j++){hi=Math.max(hi,high[j]);lo=Math.min(lo,low[j])}K.push(i>=k-1?((close[i]-lo)/(hi-lo||1))*100:NaN)}return {k:K,d:sma(K,d)}}
export function macd(close:number[],f=12,s=26,sg=9){const ef=ema(close,f),es=ema(close,s);let m:number[]=[];for(let i=0;i<close.length;i++)m.push(ef[i]-es[i]);const sig=ema(m,sg);let h:number[]=[];for(let i=0;i<close.length;i++)h.push(m[i]-sig[i]);return {m,sig,h}}
export type OHLC={time:number[];open:number[];high:number[];low:number[];close:number[]}
export function pivots(o:OHLC,win=10,tol=0.01){let highs:{i:number;p:number}[]=[],lows:{i:number;p:number}[]=[];for(let i=win;i<o.close.length-win;i++){let isH=true,isL=true;for(let j=i-win;j<=i+win;j++){if(o.high[j]>o.high[i])isH=false;if(o.low[j]<o.low[i])isL=false;if(!isH&&!isL)break}if(isH)highs.push({i,p:o.high[i]});if(isL)lows.push({i,p:o.low[i]})}function cluster(a:{i:number;p:number}[]){a.sort((x,y)=>x.p-y.p);let out:{level:number;hits:number}[]=[];for(const x of a){const lv=out.find(z=>Math.abs(z.level-x.p)/z.level<=tol);if(lv)lv.hits++;else out.push({level:x.p,hits:1})}return out}
return {highs,lows,levels:cluster(highs.concat(lows))}}

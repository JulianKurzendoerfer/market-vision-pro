export type OHLC={time:number;open:number;high:number;low:number;close:number}
export function sma(a:number[],p:number){const out:number[]=[];let s=0;for(let i=0;i<a.length;i++){s+=a[i];if(i>=p)s-=a[i-p];out.push(i>=p-1?s/p:NaN)}return out}
export function ema(a:number[],p:number){const out:number[]=[];const k=2/(p+1);let e=a[0]??0;for(let i=0;i<a.length;i++){e=i===0?a[i]:a[i]*k+e*(1-k);out.push(e)}return out}
export function std(a:number[],p:number){const out:number[]=[];let s=0,ss=0;for(let i=0;i<a.length;i++){const v=a[i];s+=v;ss+=v*v;if(i>=p){s-=a[i-p];ss-=a[i-p]*a[i-p]}if(i>=p-1){const m=s/p;out.push(Math.sqrt(Math.max(0,ss/p-m*m)))}else out.push(NaN)}return out}
export function bollinger(close:number[],p=20,k=2){const m=sma(close,p);const sd=std(close,p);const up:number[]=[],lo:number[]=[];for(let i=0;i<close.length;i++){up.push(m[i]+k*sd[i]);lo.push(m[i]-k*sd[i])}return {mid:m,upper:up,lower:lo}}
export function rsi(close:number[],p=14){const out:number[]=[];let up=0,down=0;for(let i=1;i<close.length;i++){const ch=close[i]-close[i-1];const g=Math.max(0,ch),l=Math.max(0,-ch);if(i<=p){up+=g;down+=l;out.push(NaN);continue}if(i===p+1){let rs=(up/p)/(down/p||1e-9);out.push(100-100/(1+rs));continue}up=(up*(p-1)+g)/p;down=(down*(p-1)+l)/p;const rs2=up/(down||1e-9);out.push(100-100/(1+rs2))}out.unshift(NaN);return out}
export function stoch(high:number[],low:number[],close:number[],k=14,d=3){const K:number[]=[];for(let i=0;i<close.length;i++){const a=Math.max(0,i-k+1);let hi=-Infinity,lo=Infinity;for(let j=a;j<=i;j++){hi=Math.max(hi,high[j]);lo=Math.min(lo,low[j])}K.push(i>=k-1?((close[i]-lo)/(hi-lo||1e-9))*100:NaN)}const D=sma(K,d);return {K,D}}
export function macd(close:number[],fast=12,slow=26,signal=9){const f=ema(close,fast);const s=ema(close,slow);const m:number[]=[];for(let i=0;i<close.length;i++)m.push(f[i]-s[i]);const sig=ema(m,signal);const hist:number[]=[];for(let i=0;i<close.length;i++)hist.push(m[i]-sig[i]);return {macd:m,signal:sig,hist}}
export function extrema(h:number[],l:number[],w=10){const highs:{idx:number;price:number}[]=[];const lows:{idx:number;price:number}[]=[];for(let i=w;i<h.length-w;i++){let isH=true,isL=true;for(let j=i-w;j<=i+w;j++){if(h[i]<h[j])isH=false;if(l[i]>l[j])isL=false;if(!isH&&!isL)break}if(isH)highs.push({idx:i,price:h[i]});if(isL)lows.push({idx:i,price:l[i]})}return {highs,lows}}
export function clusterLevels(vals:number[],tolPct=1){const t=tolPct/100;const s=vals.slice().sort((a,b)=>a-b);const cl:number[]=[];for(const v of s){if(cl.length===0||Math.abs(v-cl[cl.length-1])>cl[cl.length-1]*t)cl.push(v);else cl[cl.length-1]=(cl[cl.length-1]+v)/2}return cl}
